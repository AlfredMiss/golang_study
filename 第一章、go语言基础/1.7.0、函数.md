# 1.7.0、函数

每一个程序都包含很多的函数：函数是基本的代码块，并且函数在Go语言中属于“一等公民”。

> *函数是组织好的、可重复使用的、用于执行指定任务的代码块*。

Go是编译型语言，所以函数编写的顺序是无关紧要的；
鉴于可读性的需求，最好把 `main()` 函数写在文件的前面，其他函数按照一定逻辑顺序进行编写（例如函数被调用的顺序）。

编写多个函数的主要目的是将一个需要很多行代码的复杂问题分解为一系列简单的任务（那就是函数）来解决。
而且，同一个任务（函数）可以被调用多次，有助于代码重用。

当函数执行到代码块最后一行（`}` 之前）或者 `return` 语句的时候会退出，其中 `return` 语句可以带有零个或多个参数；
这些参数将作为返回值供调用者使用。简单的 `return` 语句也可以用来结束 `for` 死循环，或者结束一个协程（`goroutine`）。

Go语言中定义函数使用`func`关键字，具体格式如下：
```
func 函数名(参数)(返回值){
    //函数体
    return 返回值列表
}
```

其中：

- 函数名：由字母、数字、下划线组成。但函数名的第一个字母不能是数字。在同一个包内，函数名也称不能重名。函数名首字母小写为私有，大写为公有。

- 参数：参数由参数变量和参数变量的类型组成，参数列表可以有0-多个，多个参数之间使用`,`分隔，不支持默认参数。

- 返回值：返回值由返回值变量和其变量类型组成，也可以只写返回值的类型不写变量名，多个返回值必须用`()`包裹，并用`,`分隔。如果只有一个返回值且不声明类型，可以省略返回值列表与括号。如果有返回值，函数内必须有`return`。

- 函数体：实现指定功能的代码块。

Go中函数常见写法：
```
//无返回值，默认返回0，所以也可以写为 func fn() int {}
func fn(){
    fmt.Println("北凉悲凉，人心不凉")
}

//Go推荐给函数返回值起一个变量名
func fn1() (result int) {
	return 1
}

//第二种返回值写法
func fn2() (result int) {
	result = 1
	return
}

//多返回值
func fn3() (int, int, int) {
   return 1,2,3
}

//Go返回值推荐多返回值写法：
func fn4() (a int, b int, c int) {	多个参数类型如果相同，可以简写为： a,b int
   a , b, c = 1, 2, 3
   return
}

//多个参数
func intSum(x int, y int) int {
	return x + y
}

```

## 函数调用

 定义了函数之后，就通过函数名()的方式调用函数。 例如我们调用上面定义的两个函数，代码如下：
```
func main() {
	fn()
	ret := intSum(10, 20)
	fmt.Println(ret)
}
```
注意，调用有返回值的函数时，可以不接收其返回值。

## 参数

##### 类型简写

函数的参数中如果相邻变量的类型相同，则可以省略类型，例如：
```
func intSum(x, y int) int {
	return x + y
}
```
上面的代码中，`intSum`函数有两个参数，这两个参数的类型均为`int`，因此可以省略 x 的类型，因为 y 后面有类型说明，x 参数也是该类型。

##### 可变参数
可变参数是指函数的参数数量不固定。

Go语言中的可变参数通过在参数名后加`...`来标识。

*注意：*可变参数通常要作为函数的最后一个参数。

举个例子：
```
func intSum2(x ...int) int {
	fmt.Println(x) //x是一个切片
	sum := 0
	for _, v := range x {
		sum = sum + v
	}
	return sum
}


//调用上面的函数
ret1 := intSum2()
ret2 := intSum2(10)
ret3 := intSum2(10, 20)
ret4 := intSum2(10, 20, 30)
fmt.Println(ret1, ret2, ret3, ret4) //0 10 30 60
```

固定参数搭配可变参数使用时，可变参数要放在固定参数的后面，示例代码如下：
```
func intSum3(x int, y ...int) int {
	fmt.Println(x, y)
	sum := x
	for _, v := range y {
		sum = sum + v
	}
	return sum
}

//调用上面的函数
ret5 := intSum3(100)
ret6 := intSum3(100, 10)
ret7 := intSum3(100, 10, 20)
ret8 := intSum3(100, 10, 20, 30)
fmt.Println(ret5, ret6, ret7, ret8) //100 110 130 160
```

本质上，函数的可变参数是通过切片来实现的


## 返回值
Go语言中通过`return`关键字向外输出返回值。

##### 多返回值

Go语言中函数支持多返回值，函数如果有多个返回值时必须用`()`将所有返回值包裹起来。
```
func calc(x, y int) (int, int) {
	sum := x + y
	sub := x - y
	return sum, sub
}
```

##### 返回值命名

函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过 `return`关键字返回
```
func calc(x, y int) (sum, sub int) {
	sum = x + y
	sub = x - y
	return
}
```


##### 返回值补充

当我们的一个函数返回值类型为`slice`时，`nil`可以看做是一个有效的`slice`，没必要显示返回一个长度为0的切片。
```
func someFunc(x string) []int {
	if x == "" {
		return nil // 没必要返回[]int{}
	}
	...
}
```


## 变量作用域

##### 全局变量

全局变量是定义在函数外部的变量，它在程序整个运行周期内都有效。 在函数中可以访问到全局变量。

```
package main

import "fmt"

//定义全局变量num
var num int64 = 10

func testGlobalVar() {
	fmt.Printf("num=%d\n", num) //函数中可以访问全局变量num
}
func main() {
	testGlobalVar() //num=10
}
```

##### 局部变量
局部变量又分为两种： 
    
1、函数内定义的变量无法在该函数外使用，例如下面的示例代码`main`函数中无法使用testLocalVar函数中定义的变量x：
```
func testLocalVar() {
	//定义一个函数局部变量x,仅在该函数内生效
	var x int64 = 100
	fmt.Printf("x=%d\n", x)
}

func main() {
	testLocalVar()
	fmt.Println(x) // 此时无法使用变量x
}
```

如果局部变量和全局变量重名，优先访问局部变量。
```
package main

import "fmt"

//定义全局变量num
var num int64 = 10

func testNum() {
	num := 100
	fmt.Printf("num=%d\n", num) // 函数中优先使用局部变量
}
func main() {
	testNum() // num=100
}

```

2、语句块定义的变量，通常我们会在if条件判断、for循环、switch语句上使用这种定义变量的方式。
```
func testLocalVar2(x, y int) {
	fmt.Println(x, y) //函数的参数也是只在本函数中生效
	if x > 0 {
		z := 100 //变量z只在if语句块生效
		fmt.Println(z)
	}
	//fmt.Println(z)//此处无法使用变量z
}

func testLocalVar3() {
	for i := 0; i < 10; i++ {
		fmt.Println(i) //变量i只在当前for语句块中生效
	}
	//fmt.Println(i) //此处无法使用变量i
}
```


## 函数类型与变量

##### 定义函数类型

使用`type`关键字来定义一个函数类型，具体格式如下：
```
type calculation func(int, int) int
```
上面语句定义了一个 calculation 类型，它是一种函数类型，这种函数接收两个`int`类型的参数并且返回一个`int`类型的返回值。

简单来说，凡是满足这个条件的函数都是calculation类型的函数，例如下面的add和sub是calculation类型。

```
func add(x, y int) int {
	return x + y
}

func sub(x, y int) int {
	return x - y
}
```
add和sub都能赋值给calculation类型的变量。
```
var c calculation
c = add
```

##### 函数类型变量
可以声明函数类型的变量并且为该变量赋值：
```
func main() {
	var c calculation               // 声明一个calculation类型的变量c
	c = add                         // 把add赋值给c
	fmt.Printf("type of c:%T\n", c) // type of c:main.calculation
	fmt.Println(c(1, 2))            // 像调用add一样调用c

	f := add                        // 将函数add赋值给变量f1
	fmt.Printf("type of f:%T\n", f) // type of f:func(int, int) int
	fmt.Println(f(10, 20))          // 像调用add一样调用f
}
```

## 高阶函数
高阶函数分为函数作为参数和函数作为返回值两部分。

##### 函数作为参数
函数可以作为参数：
```
func add(x, y int) int {
	return x + y
}
func calc(x, y int, op func(int, int) int) int {
	return op(x, y)
}
func main() {
	ret2 := calc(10, 20, add)
	fmt.Println(ret2) //30
}
```

##### 函数作为返回值
函数也可以作为返回值：
```
func do(s string) (func(int, int) int, error) {
	switch s {
	case "+":
		return add, nil
	case "-":
		return sub, nil
	default:
		err := errors.New("无法识别的操作符")
		return nil, err
	}
}
```


## 匿名函数
函数当然还可以作为返回值，但是在Go语言中函数内部不能再像之前那样定义函数了，只能定义匿名函数。

匿名函数就是没有函数名的函数，匿名函数的定义格式如下：
```
func(参数)(返回值){
    函数体
}
```

匿名函数因为没有函数名，所以没办法像普通函数那样调用，所以匿名函数需要保存到某个变量或者作为立即执行函数:
```
func main() {
	// 将匿名函数保存到变量
	add := func(x, y int) {
		fmt.Println(x + y)
	}
	add(10, 20) // 通过变量调用匿名函数

	//自执行函数：匿名函数定义完加()直接执行
	func(x, y int) {
		fmt.Println(x + y)
	}(10, 20)
}
```

匿名函数多用于实现回调函数和闭包。

## 闭包
闭包指的是一个函数和与其相关的引用环境组合而成的实体。

简单来说，闭包=函数+引用环境。示例如下：
```
func adder() func(int) int {
	var x int
	return func(y int) int {
		x += y
		return x
	}
}
func main() {
	var f = adder()
	fmt.Println(f(10)) //10
	fmt.Println(f(20)) //30
	fmt.Println(f(30)) //60

	f1 := adder()
	fmt.Println(f1(40)) //40
	fmt.Println(f1(50)) //90
}
```

变量f是一个函数并且它引用了其外部作用域中的x变量，此时f就是一个闭包。 在f的生命周期内，变量x也一直有效。
闭包示例1：
```
func adder2(x int) func(int) int {
	return func(y int) int {
		x += y
		return x
	}
}
func main() {
	var f = adder2(10)
	fmt.Println(f(10)) //20
	fmt.Println(f(20)) //40
	fmt.Println(f(30)) //70

	f1 := adder2(20)
	fmt.Println(f1(40)) //60
	fmt.Println(f1(50)) //110
}
```

闭包示例2：

```
func makeSuffixFunc(suffix string) func(string) string {
	return func(name string) string {
		if !strings.HasSuffix(name, suffix) {
			return name + suffix
		}
		return name
	}
}

func main() {
	jpgFunc := makeSuffixFunc(".jpg")
	txtFunc := makeSuffixFunc(".txt")
	fmt.Println(jpgFunc("test")) //test.jpg
	fmt.Println(txtFunc("test")) //test.txt
}
```

闭包示例3：
```
func calc(base int) (func(int) int, func(int) int) {
	add := func(i int) int {
		base += i
		return base
	}

	sub := func(i int) int {
		base -= i
		return base
	}
	return add, sub
}

func main() {
	f1, f2 := calc(10)
	fmt.Println(f1(1), f2(2)) //11 9
	fmt.Println(f1(3), f2(4)) //12 8
	fmt.Println(f1(5), f2(6)) //13 7
}
```

闭包其实并不复杂，只要牢记闭包=函数+引用环境

### 内置函数介绍
![](_v_images/20201224133435487_10614.png)

## 异常机制：panic/recover

Go语言中目前是没有异常机制，但是使用`panic/recover`模式来处理错误。
`panic`可以在任何地方引发，但`recover`只有在`defer`调用的函数中有效。 
手动触发异常，是非常简单的一件事，只需要调用 `panic` 这个内置函数即可。
首先来看一个例子：

```
func funcA() {
	fmt.Println("func A")
}

func funcB() {
	panic("panic in B")
}

func funcC() {
	fmt.Println("func C")
}
func main() {
	funcA()
	funcB()
	funcC()
}
```

结果输出如下：
```func A
panic: panic in B

goroutine 1 [running]:
main.funcB(...)
        .../code/func/main.go:12
main.main()
        .../code/func/main.go:20 +0x98
```



##### 捕获panic
程序运行期间funcB中引发了`panic`导致程序崩溃，异常退出了。这个时候我们就可以通过`recover`将程序恢复回来，继续往后执行。
```
func funcA() {
	fmt.Println("func A")
}

func funcB() {
	defer func() {
		err := recover()
		//如果程序出出现了panic错误,可以通过recover恢复过来
		if err != nil {
			fmt.Println("recover in B")
		}
	}()
	panic("panic in B")
}

func funcC() {
	fmt.Println("func C")
}
func main() {
	funcA()
	funcB()
	funcC()
}
```

注意：

- `recover()`必须搭配`defer`使用。其他作用域下，它是不工作的。。
- `defer`一定要在可能引发`panic`的语句之前定义。

通常来说，不应该对进入 `panic` 异常的程序做任何处理，但有时，需要我们可以从宕机中恢复，至少我们可以在程序崩溃前，做一些操作，举个例子，当 web 服务器遇到不可预料的严重问题时，在崩溃前应该将所有的连接关闭，如果不做任何处理，会使得客户端一直处于等待状态，如果 web 服务器还在开发阶段，服务器甚至可以将异常信息反馈到客户端，帮助调试。


##### 无法跨协程
从上面的例子，可以看到，即使 panic 会导致整个程序退出，但在退出前，若有 defer 延迟函数，还是得执行完 defer 。

但是这个 defer 在多个协程之间是没有效果，在子协程里触发 panic，只能触发自己协程内的 defer，而不能调用 main 协程里的 defer 函数的。

来做个实验就知道了
```
import (
    "fmt"
    "time"
)

func main() {
    // 这个 defer 并不会执行
    defer fmt.Println("in main")

    go func() {
        defer println("in goroutine")
        panic("")
    }()

    time.Sleep(2 * time.Second)
}
```

输出如下:
```
in goroutine
panic:

goroutine 6 [running]:
main.main.func1()
        E:/Go-Code/main.go:12 +0x7b
created by main.main
        E:/Go-Code/main.go:10 +0xbc
exit status 2
```

##### 总结

Golang 异常的抛出与捕获，依赖两个内置函数：

- `panic`：抛出异常，使程序崩溃
- `recover`：捕获异常，恢复程序或做收尾工作

`revocer` 调用后，抛出的 `panic` 将会在此处终结，不会再外抛，但是 `recover`，并不能任意使用，它有强制要求，必须得在 `defer` 下才能发挥用途。